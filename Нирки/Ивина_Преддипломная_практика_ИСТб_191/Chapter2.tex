\chapter{Реализация методов построения цифровых моделей местности}

\section{Подготовка исходных данных для построения матриц }

В данной работе описаны методы построения цифровых матриц, отражающих характеристики местности, такие как: матрицы залегания грунтовых вод, матрицы коэффициента фильтрации и матрицы коэффициента пористости, построенные по векторным картам, содержащим в себе по 13 исходных точек. В качестве исходных данных для построения векторных карт были использованы данные геодезической съемки, результаты исследования почвы в скважинах и в пределах продольных профилей рек. Для того, чтобы все матрицы получались одинаковыми по размеру, была создана рамка, как отдельная векторная карта (рисунок~\ref{fig:8}).

\begin{figure}[h!]
    \center
    \includegraphics[scale=0.5]{images/1111.jpg}
    \caption{Векторная карта рамки}
    \label{fig:8}
\end{figure}


С помощью координат четырех точек были вычислены ширина и высота рамки, это необходимо для того, чтобы понять какую размерность будет иметь матрица на входе и выходе программы. Координаты были взяты из таблицы информации об объекте (рисунок~\ref{fig:9}).

\begin{figure}[h!]
    \center
    \includegraphics[scale=0.3]{images/222.jpg}
    \caption{Таблица с координатами рамки}
    \label{fig:9}
\end{figure}

Размер одного элемента в матрице равняется 15 метрам, исходя из этого делим ширину и высоту на размер одного элемента, для получения значений $N$ (количество столбцов матрицы) и $M$ (количество строк матрицы), полученная размерность: $N = 61$,  $M = 50$.

Так как для построения матриц качеств известно всего 13 значений, нужно достраивать матрицы определенного размера с помощью методов интерполяции, описанных ниже.

\section{Описание основных методов для построения цифровых моделей местности}

\subsection{Метод ReadFile для записи известных значений в матрицу из файла}

Метод ReadFile считывает и записывает в матрицу известные значения, которые расположены на векторной карте как точки (рисунок~\ref{fig:10}). Те точки, которые нам неизвестны, заполнены нулями. Реализация метода ReadFile представлена в листинге \ref{ls:01}.

Для того, чтобы известные значения записывались в правильные ячейки матрицы, а именно, в тех же местах, что и на карте, необходимо из координат $X$ и $Y$ вычесть начальную координату $X$ и $Y$ рамки и поделить на размер элемента равный 15. Тогда все известные значения запишутся в те ячейки матрицы, в которых они находятся.

\begin{lstlisting}[caption={Метод ReadFile}, label={ls:01}]
static public void ReadFile(string file)
{
    string line = "t";
    string[] splitLine;
    int X, Y;
    StreamReader sr = new StreamReader(file);
    while (line != null)
    {
        line = sr.ReadLine();
        try
        {
            line = Regex.Replace(line," +", "");
            line = Regex.Replace(line, "[.]", ","); 
            splitLine = line.Split("|");
            X = (int)((Double.Parse(splitLine[3])) - START_X) / H;
            Y = (int)(Double.Parse(splitLine[4]) - START_Y) / H;
            MATRIX[X, Y] = Double.Parse(splitLine[5]);  
        }
        catch { }
    }
}
\end{lstlisting}

\begin{figure}[h!]
    \center
    \includegraphics[scale=0.3]{images/333.jpg}
    \caption{Векторная карта с входными значениями}
    \label{fig:10}
\end{figure}


\subsection{Метод Calculate для заполнения неизвестных значений в матрице}

Данный метод заполняет значения матрицы, полученные с помощью метода интерполяции обратно взвешенных расстояний. Реализация данного метода представлена в листинге~\ref{ls:02}.

\begin{lstlisting}[caption={Метод Calculate}, label={ls:02}]
static double[,] calculate()
{
    double[,] grid = new double[N,M];
    for(int i = 0; i < N; i++)
    {
        for(int j = 0; j < M; j++)
        {
            grid[i,j] = idw(i, j);
        }
    }
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < M; j++)
        {
            if (MATRIX[i,j] != 0)
            {
                grid[i, j] = MATRIX[i, j];
            }
        }
    }
    return grid;
}
\end{lstlisting}

Полученную матрицу необходимо записать в файл, где в первом столбце содержится координата $X$, затем координата $Y$ и значение в этой точке. Метод WriteFile представлен в листинге~\ref{ls:03}. Выводится все в таком порядке не случайно, для того чтобы при импорте матрицы в любую программу для отображения поверхности не было ошибок и файл считывался корректно любой другой программой. После отработки программы получаем выходной файл (рисунок~\ref{fig:11}). 


\begin{lstlisting}[caption={Метод WriteFile}, label={ls:03}]
        static void writeFile(double[,] grid)
        {
            StreamWriter sw = new StreamWriter("filtr.txt");
            for (int i = 0; i < N; i++)
            {
                for (int j = 0; j < M; j++)
                {
                    sw.WriteLine(Convert.ToString(i * 50 + START_X) + " " + Convert.ToString(j * 50 + START_Y)+ " " + Convert.ToString(grid[i, j]));
                }
            }
        }
\end{lstlisting}

\begin{figure}[h!]
    \center
    \includegraphics[scale=0.8]{images/555.jpg}
    \caption{Файл с выходными значениями}
    \label{fig:11}
\end{figure}

\subsection{Реализация метода интерполяции обратно взвешенных расстояний}

Для того, чтобы заполнить матрицу значениями, их необходимо вычислить с использованием различных методов интерполяции. В листинге~\ref{ls:04} приведена функция, которая реализовывает метод интерполяции обратно взвешенных расстояний, для нахождения значений в тех точках, что обозначены нулями по формуле~\ref{e:f(p)}. 

\begin{equation} \label{e:f(p)}
f(\overline{p}) =  \frac{\sum_{i=1}^{n}{w_i(\overline{p}) * z_i}}{\sum_{i=1}^{n}{w_i(\overline{p})}},
\end{equation}
где \(w_i(\overline{p}) = \mid \overline{p}-\overline{p}_i \mid ^{-k}\) -- функция взвешивания обратного расстояния, $n$ -- количество опорных точек, $z_i$ -- значение функции в опорной точке, $\overline{p}$ -- координата искомой точки,  $\overline{p}_i$ -- координата опорной точки.

Для того, чтобы посчитать значение в точке $p$, необходимо рассчитать квадратный корень расстояния до известной точки и разделить значение $z$ в этой известной точке на посчитанный корень расстояния~\cite{25, 27}. 

\begin{lstlisting}[caption={Метод средневзвешенной интерполяции}, label={ls:04}]
static double idw(int cx, int cy)
        {
            double res = 0, num = 0, denom = 0;
            for (int i = 0; i < 12; i++)
            {
                if(Math.Abs(Math.Pow(cx - _X[i], 2) + Math.Pow(cy - _Y[i], 2)) == 0)
                {
                    return 0;
                }
                else
                {
                    num += _Z[i] / Math.Abs(Math.Pow(cx - _X[i], 2) + Math.Pow(cy - _Y[i], 2));
                    denom += 1 / Math.Abs(Math.Pow(cx - _X[i], 2) + Math.Pow(cy - _Y[i], 2));
                }
            }
            res = num / denom;
            return res;
        }
\end{lstlisting}

\subsection{Реализация метода интерполяции сплайнами}

Сплайн интерполяция производится за счет создания поверхности, проходящей через все опорные точки при соблюдении условия минимальной кривизны~\cite{24,26}. Сплайн-поверхность определяется формулой~\ref{e:f(xy)}. 
\begin{equation} \label{e:f(xy)}
f(x,y) = \sum^N_{i=1} C_i *[(x - x_i)^2 + (y - y_i)^2] * ln[(x - x_i)^2 + (y- y_i)^2] + Ax + By + D,
\end{equation}
где $C_i$, $A$, $B$, $D$ -- некоторые постоянные коэффициенты, $(x_i, y_i)$ - координаты опорных точек.

Для нахождения коэффициентов, необходимо решить систему линейных алгебраических уравнений (СЛАУ) вида~\ref{e:slau}. 

\begin{equation} \label{e:slau}
\begin{pmatrix}
 0 &  \phi_{12} & \phi_{13} & ... & \phi_{1n} & x_1 & y_1 & 1 \\ 
 \phi_{21} & 0 & \phi_{23} & ... & \phi_{2n} & x_2 & y_2 & 1 \\ 
 \phi_{31} & \phi_{32} & 0 & ... & \phi_{3n} & x_3 & y_3 & 1 \\ 
 ... & ... & ... & ... & ... & ... & ... & ... \\ 
 \phi_{n1} & \phi_{n2} & \phi_{n3} & ... & 0 & x_n & y_n & 1 \\ 
 1 & 1 & 1 & ... & 1 & 0 & 0 & 0 \\ 
 x_1 & x_2 & x_3 & ... & x_n & 0 & 0 & 0\\ 
 y_1 & y_2 & y_3 & ... & y_n & 0 & 0 & 0
\end{pmatrix} * \begin{pmatrix}
C_1\\ 
C_2\\ 
C_3\\ 
...\\ 
C_n\\ 
A\\ 
B\\ 
D
\end{pmatrix} = \begin{pmatrix}
z_1\\ 
z_2\\ 
z_3\\ 
...\\ 
z_n\\ 
0\\ 
0\\ 
0
\end{pmatrix},
\end{equation}
где $\phi_{ij}$ = $[(x_i - x_j)^2 + (y_i - y_j)^2] * ln[(x_i - x_j)^2 + (y_i - y_j)^2]$, $C_i$, $A$, $B$, $D$ -- искомые коэффициенты для сплайн-поверхности.

Для решения системы был выбран метод Гаусса для СЛАУ, так как неудалось привести матрицу к трехдиагональному виду для решения методом прогонки. В листинге~\ref{ls:a:01} представлен метод реализующий подготовку матриц для решения СЛАУ методом Гаусса и заполнение интерполированных точек в сетку вывода.


\subsection{Реализация метода интерполяции с использованием радиально-базисной функции }
Радиально-базисной функцией называется функция зависящая от расстояния между искомой точкой и опорной точкой~\cite{27}. В качестве радиально-базисной функции используется метрика Евклидового расстояния (формула~\ref{e:Evk}). 
\begin{equation} \label{e:Evk}
\phi_i(x,y) = \sqrt{(x-x_i)^2 * (y-y_i)^2}.
\end{equation}

Функция интерполируется в данном методе с помощью взвешенной суммы радиально-базисных функций (формула~\ref{e:sum}). 
\begin{equation} \label{e:sum}
f(x, y) = \sum ^N _{i=1} w_i*\phi_i(x,y) ,
\end{equation}
где $w_i$ -- веса.

Для того чтобы определить веса точек, необходимо решить систему уравнений~\ref{e:sys2}. 
\begin{small}
\begin{equation} \label{e:sys2}
\begin{pmatrix}
1 & \phi_1(x_2, y_2) & \phi_1(x_3, y_3) & ... & \phi_1(x_n, y_n)\\ 
\phi_2(x_1, y_1) & 1 & \phi_2(x_3, y_3) & ... & \phi_2(x_n, y_n)\\ 
\phi_3(x_1, y_1) & \phi_3(x_2, y_2) & 1 & ... & \phi_3(x_n, y_n)\\ 
... & ... & ... & ... & ... \\ 
\phi_n(x_1, y_1) & \phi_n(x_2, y_2) & ... &  \phi_n(x_{n-1}, y_{n-1}) &  1\\ 
\end{pmatrix} * \begin{pmatrix}
w_1\\ 
w_2\\ 
w_3\\ 
...\\ 
w_n
\end{pmatrix} = \begin{pmatrix}
z_1\\ 
z_2\\ 
z_3\\ 
...\\ 
z_n
\end{pmatrix}
\end{equation}
\end{small}

Данная система решается методом Гаусса для СЛАУ. В листинге~\ref{ls:a:02} представлен метод, реализующий подготовку матриц для решения СЛАУ методом Гаусса и заполнение интерполированных точек в сетку вывода.


